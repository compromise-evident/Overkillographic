<!--
Transform images into bizarre absurdity, and experiment with data-image.
-->



![9 1MB](https://user-images.githubusercontent.com/75550631/228114557-75d1867a-eae0-45a6-885d-379e320eac5d.gif)



<p align="center">
  <img src="https://raw.githubusercontent.com/compromise-evident/Overkillographic/main/Other/Frame_1.jpg">
</p>

<p align="center">
  <img src="https://raw.githubusercontent.com/compromise-evident/Overkillographic/main/Other/Frame_2.jpg">
</p>

These are real-life frames taken from [youtube.com/watch?v=tO01J-M3g0U](https://www.youtube.com/watch?v=tO01J-M3g0U)
Full GIF is 93MB; unrender-able.

<br>

<p align="center">
  <img src="https://raw.githubusercontent.com/compromise-evident/Overkillographic/main/Other/Terminal_bfc6af18cd7b4a361425a38b741379af6931234e14fcc35f36c011a3055c7edc.png">
</p>

[Auditing in the browser?](https://coliru.stacked-crooked.com/a/252c0e681e6602d0)

<br>

# What else

* Experiment with EXIF stripping.
* Create bar/QR codes through segmented writing.
* Hence a good RICIN system for groupOTP & schemeOTP.
* Mass do things to other files (C++ easily modifiable.)
* Hide information in videos, images, and GIFs.
* Adjust Byte modification for other styles (cpp line 218.)
* Enjoy the crazy acid perspective.

# Experiment now

Overkillographic first converts the image to bmp then copies the first 10,000
Bytes of that bmp in order to create a new bmp of the same parameters. Remaining
Bytes can be anything you wish, even terabytes of garbage data; when viewing the
new bmp, the Bytes used are the first n which fill a canvas of original bmp
parameters. So, you may write segmented Bytes in repetition and create a bar-code.
Here, after copying the first 10,000 Bytes, remaining Bytes are taken from the
original bmp, modified, and appended to the new bmp until I run out of Bytes
to take, making both bmps equal in size. This new bmp is then converted to jpg.
