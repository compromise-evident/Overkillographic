<!--
Transform images into bizarre absurdity, and experiment with data-image.
-->



![9 1MB](https://user-images.githubusercontent.com/75550631/228114557-75d1867a-eae0-45a6-885d-379e320eac5d.gif)



<p align="center">
  <img src="https://raw.githubusercontent.com/compromise-evident/Overkillographic/main/Other/Frame_1.jpg">
</p>

<p align="center">
  <img src="https://raw.githubusercontent.com/compromise-evident/Overkillographic/main/Other/Frame_2.jpg">
</p>

These are real-life frames taken from [youtube.com/watch?v=tO01J-M3g0U](https://www.youtube.com/watch?v=tO01J-M3g0U)
GIF is squeezed for render-ability.

<p align="center">
  <img src="https://raw.githubusercontent.com/compromise-evident/Overkillographic/main/Other/Terminal_8e7e3ab08d8ba018298d10a37d38566f3e9da3b0e0d3fffa648d67646cf0b34a.png">
</p>

[Auditing in the browser?](https://coliru.stacked-crooked.com/a/b30432a6674ec00f)

<br>
<br>

# What else

* Experiment with EXIF stripping.
* Create bar/QR codes through segmented writing.
* Hence a good RICIN system for groupOTP & schemeOTP.
* Mass do things to other files (C++ easily modifiable.)
* Hide information in videos, images, and GIFs.
* Adjust Byte modification for other styles (cpp line 218.)
* Enjoy the crazy acid perspective.

<br>
<br>

# Experiment now

Overkillographic first converts the image to bmp then copies the first 10,000
Bytes from that bmp in order to create a new bmp of the same parameters. Remaining
Bytes can be anything you wish, even terabytes of garbage data; when viewing the
new bmp, n Bytes are read, n being the exact file size of the original bmp.
So, you may write segmented Bytes in repetition and create a bar-code.
Here, after copying the first 10,000 Bytes, remaining Bytes are taken from the
original bmp, modified, and appended to the new bmp until I run out of Bytes
to take, making both bmps equal in size. This new bmp is then converted to jpg.
